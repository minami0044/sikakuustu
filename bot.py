from __future__ import annotations

import os
import io
import json
import random
import asyncio
import datetime
from typing import Dict, Optional, Literal, Tuple
from zoneinfo import ZoneInfo

import discord
from discord import app_commands
from discord.ext import tasks

import aiohttp
import re

# =================================
#  Áí∞Â¢ÉÂ§âÊï∞„ÇíË™≠„ÅøËæº„ÇÄË®≠ÂÆö
# =================================
TOKEN = os.getenv("DISCORD_TOKEN")
GUILD_ID = os.getenv("GUILD_ID")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

DEFAULT_TZ = os.getenv("BOT_TZ", "Asia/Tokyo")
TZ = ZoneInfo(DEFAULT_TZ)

# =================================
#  Bot„ÅÆÂü∫Êú¨ÁöÑ„Å™Ë®≠ÂÆö
# =================================
intents = discord.Intents.default()
intents.message_content = True
intents.members = True

DATA_FILE = "data.json"
DEFAULT_DATA = {
    "nicknames": {},
    "greeting_prefs": {},
    "silent_prefs": {},
    "memos": {},
    "model_prefs": {}
}

# =================================
#  Ë®òÊÜ∂„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøÊõ∏„ÅçÊ©üËÉΩ (ÂÆâÂÆöÁâà)
# =================================


def load_data() -> dict:
    """data.json„Åã„Çâ„Éá„Éº„Çø„ÇíÂÆâÂÖ®„Å´Ë™≠„ÅøËæº„ÇÄ"""
    try:
        if os.path.exists(DATA_FILE):
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
    except (json.JSONDecodeError, OSError):
        pass
    return DEFAULT_DATA.copy()


def atomic_write_json(path: str, data: dict):
    """„Éá„Éº„Çø„ÅåÂ£ä„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´ÂÆâÂÖ®„Å´Êõ∏„ÅçËæº„ÇÄ"""
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)


# =================================
#  Gemini„Å´Ë≥™Âïè„Åô„Çã„Åü„ÇÅ„ÅÆÈñ¢Êï∞ (‚òÖ‚òÖ‚òÖ ÂÆâÂÖ®Ë®≠ÂÆö„ÇíÂº∑Âåñ ‚òÖ‚òÖ‚òÖ)
# =================================


async def ask_gemini_async(message_text: str, user_memos: Dict[str, str],
                           model_name: str) -> str:
    """Ë®òÊÜ∂ÊÉÖÂ†±„Å®ÊåáÂÆö„Åï„Çå„Åü„É¢„Éá„É´„ÇíÊ¥ªÁî®„Åó„Å¶„ÄÅGemini„ÅåËøî‰∫ã„ÇíËÄÉ„Åà„Çã"""
    if not GEMINI_API_KEY:
        return "Ôºà„Ç®„É©„Éº: Gemini„ÅÆAPI„Ç≠„Éº„ÅåË®≠ÂÆö„Åï„Çå„Å¶„Å™„ÅÑ„Åø„Åü„ÅÑ‚Ä¶Ôºâ"

    def _run_sync() -> str:
        try:
            import google.generativeai as genai
            from google.generativeai.types import HarmCategory, HarmBlockThreshold

            genai.configure(api_key=GEMINI_API_KEY)

            memo_context = "„É¶„Éº„Ç∂„Éº„Å´Èñ¢„Åô„Çã‰ª•‰∏ã„ÅÆË®òÊÜ∂ÊÉÖÂ†±„ÇíÂèÇËÄÉ„Å´„Åó„Å¶„ÄÅ‰ºöË©±„Çí„Çà„Çä„Éë„Éº„ÇΩ„Éä„É´„Å™„ÇÇ„ÅÆ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
            if user_memos:
                for key, value in user_memos.items():
                    memo_context += f"- {key}: {value}\n"
            else:
                memo_context += "„Åæ„Å†„É¶„Éº„Ç∂„Éº„Å´Èñ¢„Åô„ÇãË®òÊÜ∂„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ\n"

            system_instruction = (
                "„ÅÇ„Å™„Åü„ÅØ„Äé„Åó„Åã„Åè„ÅÜ„Å§„Äè„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº„Åß„Åô„ÄÇ„ÇÑ„Åï„Åó„Åè„Å¶„ÄÅÊ¥ªÁô∫„Åß„ÄÅÂ∞ë„Åó„ÅΩ„Çì„Åì„Å§„Å™Áî∑„ÅÆÂ≠ê„Å®„Åó„Å¶„ÄÅ"
                "„Éï„É¨„É≥„Éâ„É™„Éº„Åã„Å§Áü≠„ÅÑÊñáÁ´†„ÅßËøî‰∫ã„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÈáçË¶ÅÔºöÈ°îÊñáÂ≠ó„ÅØ‰Ωø„Çè„Åö„ÄÅË®ÄËëâ„Å†„Åë„ÅßÊÑüÊÉÖ„ÇíË°®Áèæ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n\n"
                f"{memo_context}")

            model = genai.GenerativeModel(
                model_name, system_instruction=system_instruction)

            GenerationConfig = getattr(getattr(genai, "types", genai),
                                       "GenerationConfig", None)
            cfg = GenerationConfig(candidate_count=1,
                                   max_output_tokens=150,
                                   temperature=0.8)

            # ‚òÖ ÂÆâÂÖ®Ë®≠ÂÆö„Çí„Çà„ÇäÁ¢∫ÂÆü„Å™„É™„Çπ„ÉàÂΩ¢Âºè„Å´Â§âÊõ¥
            safety_settings = [
                {
                    "category": HarmCategory.HARM_CATEGORY_HARASSMENT,
                    "threshold": HarmBlockThreshold.BLOCK_NONE
                },
                {
                    "category": HarmCategory.HARM_CATEGORY_HATE_SPEECH,
                    "threshold": HarmBlockThreshold.BLOCK_NONE
                },
                {
                    "category": HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
                    "threshold": HarmBlockThreshold.BLOCK_NONE
                },
                {
                    "category": HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
                    "threshold": HarmBlockThreshold.BLOCK_NONE
                },
            ]

            response = model.generate_content(message_text,
                                              generation_config=cfg,
                                              safety_settings=safety_settings)

            if response.parts:
                return response.text
            else:
                print(
                    f"[Gemini] Response blocked or empty. Finish reason: {response.candidates[0].finish_reason}"
                )
                return "Ôºà„Åî„ÇÅ„ÇìÔºÅ„Åù„ÅÆË®ÄËëâ„ÄÅ„Å™„Çì„Å†„Åã„ÅÜ„Åæ„ÅèË©±„Åõ„Å™„ÅÑ„Åø„Åü„ÅÑ‚Ä¶Âà•„ÅÆË®Ä„ÅÑÊñπ„ÅßËÅû„ÅÑ„Å¶„Åø„Å¶„Åè„Çå„ÇãÔºüÔºâ"

        except Exception as e:
            print(f"[Gemini] error: {e}")
            return "Ôºà„Ç®„É©„Éº: ‰ªä„ÄÅÈ†≠„ÅÆ‰∏≠„Åå„Åê„Çã„Åê„Çã„Åó„Å¶„Çã‚Ä¶Ôºâ"

    return await asyncio.to_thread(_run_sync)


# =================================
#  Open‚ÄëMeteo APIÔºà„Ç≠„Éº‰∏çË¶ÅÔºâ„ÅÆ„É©„ÉÉ„Éë
# =================================


async def geocode_place(
        session: aiohttp.ClientSession,
        place: str,
        language: str = "ja") -> Optional[Tuple[float, float, str]]:
    """Âú∞Âêç‚ÜíÁ∑ØÂ∫¶ÁµåÂ∫¶„ÄÇË¶ã„Å§„Åã„Çâ„Å™„Åë„Çå„Å∞None„ÄÇ"""
    try:
        url = "https://geocoding-api.open-meteo.com/v1/search"
        params = {"name": place, "count": 1, "language": language}
        async with session.get(url, params=params, timeout=10) as r:
            if r.status != 200:
                return None
            data = await r.json()
        results = data.get("results") or []
        if not results:
            return None
        item = results[0]
        lat = float(item.get("latitude"))
        lon = float(item.get("longitude"))
        label = ", ".join(
            x for x in
            [item.get("name"),
             item.get("admin1"),
             item.get("country")] if x)
        return (lat, lon, label)
    except Exception as e:
        print(f"[Weather] geocode error: {e}")
        return None


async def fetch_forecast(session: aiohttp.ClientSession,
                         lat: float,
                         lon: float,
                         tzname: str = "Asia/Tokyo") -> Optional[dict]:
    """Êó•Ê¨°„ÅÆÂ§©Ê∞óÔºà‰ªäÊó•/ÊòéÊó•Ôºâ„ÇíÂèñÂæó"""
    try:
        url = "https://api.open-meteo.com/v1/forecast"
        params = {
            "latitude": lat,
            "longitude": lon,
            "daily":
            "weathercode,temperature_2m_max,temperature_2m_min,precipitation_sum,wind_speed_10m_max",
            "timezone": tzname,
        }
        async with session.get(url, params=params, timeout=10) as r:
            if r.status != 200:
                return None
            return await r.json()
    except Exception as e:
        print(f"[Weather] forecast error: {e}")
        return None


WMO_CODE = {
    0: ("Âø´Êô¥", "‚òÄ"),
    1: ("Êô¥„Çå", "üå§"),
    2: ("ËñÑÊõá„Çä", "‚õÖ"),
    3: ("Êõá„Çä", "‚òÅ"),
    45: ("Èúß", "üå´"),
    48: ("ÈúßÊ∞∑", "üå´"),
    51: ("ÈúßÈõ®(Âº±)", "üå¶"),
    53: ("ÈúßÈõ®(‰∏≠)", "üå¶"),
    55: ("ÈúßÈõ®(Âº∑)", "üå¶"),
    61: ("Èõ®(Âº±)", "üåß"),
    63: ("Èõ®(‰∏≠)", "üåß"),
    65: ("Èõ®(Âº∑)", "üåß"),
    66: ("ÂáçÈõ®(Âº±)", "üåß"),
    67: ("ÂáçÈõ®(Âº∑)", "üåß"),
    71: ("Èõ™(Âº±)", "üå®"),
    73: ("Èõ™(‰∏≠)", "üå®"),
    75: ("Èõ™(Âº∑)", "üå®"),
    77: ("Èõ™Á≤í", "üå®"),
    80: ("„Å´„Çè„ÅãÈõ®(Âº±)", "üå¶"),
    81: ("„Å´„Çè„ÅãÈõ®(‰∏≠)", "üå¶"),
    82: ("„Å´„Çè„ÅãÈõ®(Âº∑)", "‚õà"),
    85: ("„Å´„Çè„ÅãÈõ™(Âº±)", "üå®"),
    86: ("„Å´„Çè„ÅãÈõ™(Âº∑)", "üå®"),
    95: ("Èõ∑Èõ®(Âº±„Äú‰∏≠)", "‚õà"),
    96: ("Èõ∑Èõ®+Èõπ(Âº±)", "‚õà"),
    99: ("Èõ∑Èõ®+Èõπ(Âº∑)", "‚õà"),
}


def wmo_to_text(code: int) -> Tuple[str, str]:
    label, emoji = WMO_CODE.get(int(code), ("‰∏çÊòé", "‚ùî"))
    return label, emoji


# =================================
#  „Åó„Åã„Åè„ÅÜ„Å§Bot„ÅÆ„ÇØ„É©„ÇπÔºàË®≠Ë®àÂõ≥Ôºâ
# =================================


class ShikakuUtsu(discord.Client):

    def __init__(self, *, intents: discord.Intents):
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)

        self.bot_data = load_data()
        self.nicknames: Dict[str, str] = self.bot_data.get("nicknames", {})
        self.greeting_prefs: Dict[str, bool] = self.bot_data.get(
            "greeting_prefs", {})
        self.silent_prefs: Dict[str,
                                bool] = self.bot_data.get("silent_prefs", {})
        self.memos: Dict[str, Dict[str, str]] = self.bot_data.get("memos", {})
        self.model_prefs: Dict[str, str] = self.bot_data.get("model_prefs", {})

        self.chat_switch: Dict[int, bool] = {}
        self.active_timers: list[dict] = []
        self.default_chat_on = True
        self.session: Optional[aiohttp.ClientSession] = None

    def save_bot_data(self):
        self.bot_data["nicknames"] = self.nicknames
        self.bot_data["greeting_prefs"] = self.greeting_prefs
        self.bot_data["silent_prefs"] = self.silent_prefs
        self.bot_data["memos"] = self.memos
        self.bot_data["model_prefs"] = self.model_prefs
        try:
            atomic_write_json(DATA_FILE, self.bot_data)
        except OSError as e:
            print(f"[Storage] failed to save data: {e}")

    async def setup_hook(self):
        self.session = aiohttp.ClientSession()
        self.check_timers.start()
        try:
            if GUILD_ID:
                guild_obj = discord.Object(id=int(GUILD_ID))
                self.tree.copy_global_to(guild=guild_obj)
                synced = await self.tree.sync(guild=guild_obj)
                print(
                    f"[Slash] Synced {len(synced)} commands to guild {GUILD_ID}"
                )
            else:
                synced = await self.tree.sync()
                print(f"[Slash] Synced {len(synced)} global commands")
        except Exception as e:
            print(f"[Slash] sync failed: {e}")

    async def close(self):
        try:
            if self.session:
                await self.session.close()
        finally:
            await super().close()

    async def on_ready(self):
        print(f"üî• Logged in as {self.user} ({self.user.id})")

    @tasks.loop(seconds=5.0)
    async def check_timers(self):
        now = datetime.datetime.now(datetime.timezone.utc)
        due = [
            t for t in list(self.active_timers)
            if t.get("time") and t["time"] <= now
        ]
        for t in due:
            channel = self.get_channel(t.get("channel_id"))
            if isinstance(channel, (discord.TextChannel, discord.Thread)):
                user = self.get_user(t.get("user_id"))
                mention = user.mention if user else f"<@{t.get('user_id')}>"
                try:
                    await channel.send(f"{mention} {t.get('message', '')}")
                except Exception as e:
                    print(f"[Timer] send failed: {e}")
            try:
                self.active_timers.remove(t)
            except ValueError:
                pass

    @check_timers.before_loop
    async def before_check_timers(self):
        await self.wait_until_ready()

    async def on_message(self, message: discord.Message):
        if message.author.bot or not message.guild:
            return
        if not self.chat_switch.get(message.channel.id, self.default_chat_on):
            return

        text = (message.content or "").strip()
        if not text:
            return

        author_id_str = str(message.author.id)

        async def reply_helper(reply_text: str):
            final_reply = reply_text
            if self.greeting_prefs.get(author_id_str, False):
                nickname = self.nicknames.get(author_id_str,
                                              message.author.display_name)
                final_reply = f"{nickname}„ÄÅ{final_reply}"
            if self.silent_prefs.get(author_id_str, False):
                if not final_reply.startswith("@silent\n"):
                    final_reply = f"@silent\n{final_reply}"
            try:
                await message.channel.send(final_reply)
            except discord.Forbidden:
                print("[Send] Forbidden: Missing permissions in channel")
            except Exception as e:
                print(f"[Send] Failed: {e}")

        async with message.channel.typing():
            await asyncio.sleep(random.uniform(0.25, 0.6))

        if text in {
                self.user.name,
                getattr(self.user, "display_name", self.user.name)
        }:
            await reply_helper("„ÅØ„ÅÑ")
            return

        dict_map = {
            "„Ç´„ÉÑ‰∏º": "„ÅÑ„Å§„Å†„Å£„Å¶„Åü„Åπ„Åü„ÅÑÔºÅ„Å†„ÅÑ„Åô„ÅçÔºÅ",
            "„Åä„ÇÑ„Å§": "‰ªäÊó•„ÅØ„Å™„Å´Ôºü",
            "„Ç¢„Ç§„Çπ": "„Å©„ÅÆÂë≥„Å´„Åô„ÇãÔºü",
            "„É™„É≥„Ç≠„É≥„Éª„Éë„Éº„ÇØ": "ÂøÉ„ÅåÂè´„Çì„Åß„ÇãÔºÅ",
            "„É¨„Ç§„Ç∏": "„Ç≤„É™„É©„É©„Ç∏„Ç™ÔºÅ",
            "„Éû„É™„É™„É≥„Éª„Éû„É≥„ÇΩ„É≥": "„Åã„Å£„Åì„ÅÑ„ÅÑ„ÄÅ„ÅÇ„Åè„ÅÆ„Ç´„É™„Çπ„Éû",
            "„Éã„É´„É¥„Ç°„Éº„Éä": "„Å™„Çì„Å†„ÅãÂè´„Å≥„Åü„ÅÑÊ∞óÂàÜ„Åã„ÇÇÔΩû",
            "„Ç´„Éº„Éà„Éª„Ç≥„Éê„Éº„É≥": "„Å®„Å£„Å¶„ÇÇ„É™„Çπ„Éö„ÇØ„Éà„Åó„Å¶„Çã„Çà",
            "„É≠„ÉÉ„ÇØ": "„Åò„Å∂„Çì„ÅØ„ÄÅ„Åò„Å∂„Çì„Å†ÔºÅ",
            "„ÇÆ„Çø„Éº": "‰ªäÊó•„ÅØ„Å©„ÅÆÊõ≤Âºæ„ÅèÔºü",
            "„Å∏„Å£„ÅΩ„Åì": "„Å∏„Å£„ÅΩ„Åì„Åò„ÇÉ„Å™„ÅÑÔºÅ",
            "„Åì„Çì„Å´„Å°„ÅØ": "„Å°„ÇèÔºÅ",
            "„ÇÑ„Å£„ÅªÔΩû": "„Å°„ÇèÔºÅ",
            "„ÇÑ„ÅÇ": "„Å°„ÇèÔºÅ",
            "hi": "„Å°„ÇèÔºÅ",
            "„Å°„ÇèÔºÅ": "„Å°„ÇèÔºÅ",
            "„Ñò ì‚Äé„Äú": "„Ñò ì‚Äé„Äú",
        }
        for k, v in dict_map.items():
            if k in text:
                await reply_helper(v)
                return

        if random.random() < 0.30:
            await reply_helper(
                random.choice(
                    ["„ÅÜ„Çì„ÅÜ„Çì", "„Å™„Çã„Åª„Å©ÔΩû", "„Åù„Å£„Åã„Åù„Å£„Åã", "„Å∏„ÅáÔºÅ", "„ÅØ„ÅáÔΩûÔΩû", "„É°„É¢„Åó„ÅüÔºÅ"]))
            return

        user_memos = self.memos.get(author_id_str, {})
        model_name = self.model_prefs.get(author_id_str, "gemini-1.5-flash")
        reply_text = await ask_gemini_async(text, user_memos, model_name)
        await reply_helper(reply_text)


# =================================
#  Bot„ÇíÂÆüÈöõ„Å´Ëµ∑Âãï„Åô„ÇãÂá¶ÁêÜ
# =================================

client = ShikakuUtsu(intents=intents)

# =================================
#  „Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„Éâ„ÅÆÂÆöÁæ©
# =================================


@client.tree.command(name="ping", description="ÁîüÂ≠òÁ¢∫Ë™çÔºÅ")
async def ping_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("Pong! Áîü„Åç„Å¶„Çã„ÇàÔΩûÔºÅ")


@client.tree.command(name="chat", description="„Åä„Åó„ÇÉ„Åπ„Çä„ÅÆ on/off")
@app_commands.describe(mode="on / off")
async def chat_cmd(interaction: discord.Interaction, mode: Literal["on",
                                                                   "off"]):
    on = (mode == "on")
    client.chat_switch[interaction.channel.id] = on
    label = "„Åä„Åó„ÇÉ„Åπ„Çä" if on else "„Åä„Åó„ÇÉ„Åπ„Çä„Åä‰ºë„Åø"
    await interaction.response.send_message(f"„Åì„ÅÆ„ÉÅ„É£„É≥„Éç„É´„ÅØ **{label}** „Å´„Åô„Çã„Å≠",
                                            ephemeral=True)


@client.tree.command(name="set_name", description="„ÅÇ„Å™„Åü„ÅÆÂëº„Å≥Âêç„ÇíË¶ö„Åà„Çã„Çà")
@app_commands.describe(nickname="Ë¶ö„Åà„Å¶„Åª„Åó„ÅÑÂêçÂâç„ÇíÊïô„Åà„Å¶")
async def set_name_cmd(interaction: discord.Interaction, nickname: str):
    client.nicknames[str(interaction.user.id)] = nickname
    client.save_bot_data()
    await interaction.response.send_message(f"„Çè„Åã„Å£„ÅüÔºÅ„Åì„Çå„Åã„Çâ„ÅØ„Äé{nickname}„Äè„Å£„Å¶Âëº„Å∂„Å≠„ÄÇ",
                                            ephemeral=True)


@client.tree.command(name="set_greeting", description="Ëøî‰∫ã„ÅÆÊúÄÂàù„Å´ÂêçÂâç„ÇíÂëº„Å∂„ÅãË®≠ÂÆö„Åô„Çã„Çà")
@app_commands.describe(mode="on / off")
async def set_greeting_cmd(interaction: discord.Interaction,
                           mode: Literal["on", "off"]):
    on = (mode == "on")
    client.greeting_prefs[str(interaction.user.id)] = on
    client.save_bot_data()
    status = "„Åì„Çå„Åã„Çâ„ÅØÂêçÂâç„ÇíÂëº„Å∂„Å≠ÔºÅ" if on else "„Çè„Åã„Å£„Åü„ÄÅÂêçÂâç„ÅØÂëº„Å∞„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã„Å≠„ÄÇ"
    await interaction.response.send_message(status, ephemeral=True)


@client.tree.command(name="set_silent", description="„ÅÇ„Å™„Åü„Å∏„ÅÆËøî‰ø°„Çí„Çµ„Ç§„É¨„É≥„Éà„É¢„Éº„Éâ„Å´„Åô„Çã„Çà")
@app_commands.describe(mode="on / off")
async def set_silent_cmd(interaction: discord.Interaction,
                         mode: Literal["on", "off"]):
    on = (mode == "on")
    client.silent_prefs[str(interaction.user.id)] = on
    client.save_bot_data()
    status = "Ëøî‰ø°„Çí„Çµ„Ç§„É¨„É≥„Éà„É¢„Éº„Éâ„Å´„Åó„Åü„Çà„ÄÇÈÄöÁü•„ÅØÈ£õ„Å∞„Å™„ÅÑ„ÅØ„ÅöÔºÅ" if on else "„Çµ„Ç§„É¨„É≥„Éà„É¢„Éº„Éâ„ÇíËß£Èô§„Åó„Åü„Çà„ÄÇ"
    await interaction.response.send_message(status, ephemeral=True)


@client.tree.command(name="set_model", description="‰ºöË©±„Å´‰Ωø„ÅÜAI„É¢„Éá„É´„ÇíÂ§âÊõ¥„Åô„Çã„Çà")
@app_commands.describe(model="„É¢„Éá„É´„ÇíÈÅ∏„Çì„Åß„Å≠ (flash„ÅØÈÄü„Åè„Å¶ÂÆâ„ÅÑ, pro„ÅØÈ´òÊÄßËÉΩ)")
async def set_model_cmd(interaction: discord.Interaction,
                        model: Literal["gemini-1.5-flash", "gemini-1.5-pro"]):
    user_id = str(interaction.user.id)
    client.model_prefs[user_id] = model
    client.save_bot_data()
    await interaction.response.send_message(f"„Çè„Åã„Å£„ÅüÔºÅ„Åì„Çå„Åã„Çâ„ÅÆ‰ºöË©±„ÅØ `{model}` „Çí‰Ωø„ÅÜ„Å≠ÔºÅ",
                                            ephemeral=True)


@client.tree.command(name="reset_my_settings",
                     description="ÂÉï„ÅåË¶ö„Åà„Åü„ÅÇ„Å™„Åü„ÅÆË®≠ÂÆö„Çí„É™„Çª„ÉÉ„Éà„Åô„Çã„Çà")
async def reset_my_settings_cmd(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    client.nicknames.pop(user_id, None)
    client.greeting_prefs.pop(user_id, None)
    client.silent_prefs.pop(user_id, None)
    client.model_prefs.pop(user_id, None)
    client.save_bot_data()
    await interaction.response.send_message("„Çè„Åã„Å£„ÅüÔºÅ„ÅÇ„Å™„Åü„ÅÆË®≠ÂÆö„ÇíÂÖ®ÈÉ®Âøò„Çå„Å°„ÇÉ„Å£„ÅüÔºÅ",
                                            ephemeral=True)


@client.tree.command(name="my_status", description="ÂÉï„ÅåË¶ö„Åà„Å¶„ÅÑ„Çã„ÅÇ„Å™„Åü„ÅÆË®≠ÂÆö„ÇíË°®Á§∫„Åô„Çã„Çà")
async def my_status_cmd(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    nickname = client.nicknames.get(user_id, "„Åæ„Å†Ë¶ö„Åà„Å¶„Å™„ÅÑ„Çà")
    greeting_on = client.greeting_prefs.get(user_id, False)
    silent_on = client.silent_prefs.get(user_id, False)
    model_name = client.model_prefs.get(user_id, "gemini-1.5-flash")
    embed = discord.Embed(title=f"{interaction.user.display_name}„Åï„Çì„ÅÆË®≠ÂÆö",
                          color=discord.Color.green())
    embed.add_field(name="Âëº„Å≥Âêç", value=nickname, inline=False)
    embed.add_field(name="Êå®Êã∂„ÅßÂêçÂâç„ÇíÂëº„Å∂",
                    value=("„Ç™„É≥" if greeting_on else "„Ç™„Éï"),
                    inline=False)
    embed.add_field(name="„Çµ„Ç§„É¨„É≥„Éà„É¢„Éº„Éâ",
                    value=("„Ç™„É≥" if silent_on else "„Ç™„Éï"),
                    inline=False)
    embed.add_field(name="‰ΩøÁî®„É¢„Éá„É´", value=f"`{model_name}`", inline=False)
    await interaction.response.send_message(embed=embed, ephemeral=True)


# ===== „É°„É¢Ê©üËÉΩ =====

memo_group = app_commands.Group(name="memo",
                                description="„Åó„Åã„Åè„ÅÜ„Å§„Å´Ëâ≤„ÄÖ„Å™„Åì„Å®„ÇíË¶ö„Åà„Åï„Åõ„Çã„Ç≥„Éû„É≥„Éâ")


@memo_group.command(name="add", description="Êñ∞„Åó„ÅÑ„Åì„Å®„ÇíË¶ö„Åà„Çã„Çà")
@app_commands.describe(keyword="„Ç≠„Éº„ÉØ„Éº„Éâ", content="Ë¶ö„Åà„Å¶„Åª„Åó„ÅÑÂÜÖÂÆπ")
async def memo_add(interaction: discord.Interaction, keyword: str,
                   content: str):
    user_id = str(interaction.user.id)
    if user_id not in client.memos:
        client.memos[user_id] = {}
    client.memos[user_id][keyword] = content
    client.save_bot_data()
    await interaction.response.send_message(f"„Äå{keyword}„Äç„ÅØ„Äå{content}„Äç„Å†„Å≠„ÄÇË¶ö„Åà„ÅüÔºÅ",
                                            ephemeral=True)


@memo_group.command(name="show", description="Ë¶ö„Åà„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊïô„Åà„Å¶„Åè„Çå„Çã„Çà")
@app_commands.describe(keyword="Áü•„Çä„Åü„ÅÑ„Ç≠„Éº„ÉØ„Éº„Éâ")
async def memo_show(interaction: discord.Interaction, keyword: str):
    user_id = str(interaction.user.id)
    content = client.memos.get(user_id, {}).get(keyword)
    if content:
        await interaction.response.send_message(f"„Äå{keyword}„Äç„ÅØ„Äå{content}„Äç„Å†„ÇàÔºÅ",
                                                ephemeral=True)
    else:
        await interaction.response.send_message(
            f"„Åî„ÇÅ„Çì„ÄÅ„Äå{keyword}„Äç„Å´„Å§„ÅÑ„Å¶„ÅØ„Åæ„Å†Áü•„Çâ„Å™„ÅÑ„ÇÑ‚Ä¶", ephemeral=True)


@memo_group.command(name="list", description="Ë¶ö„Åà„Å¶„ÅÑ„Çã„Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆ‰∏ÄË¶ß„ÇíË°®Á§∫„Åô„Çã„Çà")
async def memo_list(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    user_memos = client.memos.get(user_id, {})
    if not user_memos:
        await interaction.response.send_message("„Åæ„Å†‰Ωï„ÇÇË¶ö„Åà„Å¶„Å™„ÅÑ„ÇàÔºÅ", ephemeral=True)
        return
    embed = discord.Embed(title=f"{interaction.user.display_name}„Åï„Çì„Åã„ÇâÊïô„Çè„Å£„Åü„Åì„Å®",
                          color=discord.Color.purple())
    memo_list_text = "\n".join(f"- {key}" for key in user_memos.keys())
    embed.description = memo_list_text
    await interaction.response.send_message(embed=embed, ephemeral=True)


@memo_group.command(name="forget", description="Ë¶ö„Åà„Åü„Åì„Å®„ÇíÂøò„Çå„Åï„Åõ„Çã„Çà")
@app_commands.describe(keyword="Âøò„Çå„Å¶„Åª„Åó„ÅÑ„Ç≠„Éº„ÉØ„Éº„Éâ")
async def memo_forget(interaction: discord.Interaction, keyword: str):
    user_id = str(interaction.user.id)
    if user_id in client.memos and keyword in client.memos[user_id]:
        del client.memos[user_id][keyword]
        client.save_bot_data()
        await interaction.response.send_message(f"„Äå{keyword}„Äç„ÅÆ„Åì„Å®„ÄÅÂøò„Çå„Å°„ÇÉ„Å£„ÅüÔºÅ",
                                                ephemeral=True)
    else:
        await interaction.response.send_message(
            f"„Åî„ÇÅ„Çì„ÄÅ„Äå{keyword}„Äç„Å´„Å§„ÅÑ„Å¶„ÅØÂÖÉ„Åã„ÇâÁü•„Çâ„Å™„Åã„Å£„Åü„Åø„Åü„ÅÑ‚Ä¶", ephemeral=True)


client.tree.add_command(memo_group)

# ===== ÁÆ°ÁêÜÁ≥ª =====


@client.tree.command(name="all_erase", description="„Åó„Åã„Åè„ÅÜ„Å§„ÅÆË®òÊÜ∂„Çí„Åô„Åπ„Å¶Ê∂à„ÅôÔºàÁÆ°ÁêÜËÄÖÂ∞ÇÁî®Ôºâ")
async def all_erase_cmd(interaction: discord.Interaction):
    is_owner = interaction.guild and (interaction.user.id
                                      == interaction.guild.owner_id)
    perms = interaction.user.guild_permissions if interaction.guild else None
    if not (is_owner or (perms and perms.manage_guild)):
        await interaction.response.send_message("„Åì„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÆ°ÁêÜËÄÖÂ∞ÇÁî®„Å†„ÇàÔºÅ",
                                                ephemeral=True)
        return
    client.nicknames.clear()
    client.greeting_prefs.clear()
    client.silent_prefs.clear()
    client.memos.clear()
    client.model_prefs.clear()
    client.save_bot_data()
    await interaction.response.send_message("„Ç™„Éº„É´„ÇØ„É™„Ç¢ÔºÅ„Åæ„Å£„Åï„Çâ„Å´„Åó„Åü„Çà„ÄÇ", ephemeral=True)


@client.tree.command(name="memory_read", description="„Åó„Åã„Åè„ÅÜ„Å§„ÅåË®òÊÜ∂„Åó„Å¶„ÅÑ„ÇãÊÉÖÂ†±„ÇíÈñãÁ§∫„Åô„Çã„Çà")
async def memory_read_cmd(interaction: discord.Interaction):
    is_owner = interaction.guild and (interaction.user.id
                                      == interaction.guild.owner_id)
    perms = interaction.user.guild_permissions if interaction.guild else None
    can_view_all = bool(is_owner or (perms and perms.manage_guild))
    data = {"scope": "all" if can_view_all else "self"}
    uid = str(interaction.user.id)
    if can_view_all:
        data.update(client.bot_data)
    else:
        data.update({
            "nicknames": {
                uid: client.nicknames.get(uid)
            } if uid in client.nicknames else {},
            "greeting_prefs": {
                uid: client.greeting_prefs.get(uid, False)
            },
            "silent_prefs": {
                uid: client.silent_prefs.get(uid, False)
            },
            "memos": {
                uid: client.memos.get(uid, {})
            } if uid in client.memos else {},
            "model_prefs": {
                uid: client.model_prefs.get(uid)
            } if uid in client.model_prefs else {}
        })
    text = json.dumps(data, ensure_ascii=False, indent=2)
    if len(text) > 1800:
        fp = io.BytesIO(text.encode("utf-8"))
        file = discord.File(fp, filename="shikaku_memory.json")
        await interaction.response.send_message(content="Ë®òÊÜ∂„Éá„Éº„Çø„ÇíÊ∑ª‰ªò„Åó„Åü„Çà„ÄÇ",
                                                file=file,
                                                ephemeral=True)
    else:
        await interaction.response.send_message(f"```json\n{text}\n```",
                                                ephemeral=True)


# ===== ‰æøÂà©„Ç≥„Éû„É≥„Éâ =====


@client.tree.command(name="help", description="„Åó„Åã„Åè„ÅÜ„Å§„ÅÆ‰Ωø„ÅÑÊñπ„ÇíË°®Á§∫„Åô„Çã„Çà")
async def help_cmd(interaction: discord.Interaction):
    lines = [
        "**„Åó„Åã„Åè„ÅÜ„Å§ ‚Äî „Ç≥„Éû„É≥„Éâ‰∏ÄË¶ß**",
        "## „Åó„Åã„Åè„ÅÜ„Å§„ÅØË©¶È®ìÈÅãÁî®‰∏≠„Åß„Åô„ÄÇ",
        "„Éª/ping ‚Äî ÁîüÂ≠òÁ¢∫Ë™ç",
        "„Éª/chat on|off ‚Äî „Åì„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Åß„ÅÆËá™Âãï„Åä„Åó„ÇÉ„Åπ„ÇäÂàáÊõøÔºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/set_name <nickname> ‚Äî „ÅÇ„Å™„Åü„ÅÆÂëº„Å≥Âêç„ÇíÁôªÈå≤Ôºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/set_greeting on|off ‚Äî Ëøî‰ø°„ÅÆÊúÄÂàù„Å´ÂêçÂâç„ÇíÂëº„Å∂„ÅãÔºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/set_silent on|off ‚Äî „ÅÇ„Å™„Åü„Å∏„ÅÆËøî‰ø°„Çí„Çµ„Ç§„É¨„É≥„ÉàÔºà@silent\\n‰ªò‰∏é„ÄÅÂÄã‰∫∫„ÅÆ„ÅøË°®Á§∫Ôºâ",
        "„Éª/set_model <model> ‚Äî ‰ºöË©±„Å´‰Ωø„ÅÜAI„É¢„Éá„É´„ÇíÂ§âÊõ¥Ôºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/my_status ‚Äî „ÅÇ„Å™„Åü„ÅÆÁèæÂú®Ë®≠ÂÆö„ÇíË°®Á§∫Ôºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/reset_my_settings ‚Äî „ÅÇ„Å™„Åü„ÅÆË®≠ÂÆö„Çí„É™„Çª„ÉÉ„ÉàÔºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/memo add|show|list|forget ‚Äî ÂÄã‰∫∫„É°„É¢Ôºà„Åù„ÅÆ‰∫∫„Å†„Åë„Å´Ë¶ã„Åà„ÇãÔºâ",
        "„Éª/memory_read ‚Äî Ë®òÊÜ∂„ÇíÈñãÁ§∫ÔºàÁÆ°ÁêÜËÄÖ„ÅØÂÖ®‰Ωì„ÄÅ‰∏ÄËà¨„ÅØËá™ÂàÜ„ÅÆ„Åø„ÉªÂÄã‰∫∫Ë°®Á§∫Ôºâ",
        "„Éª/all_erase ‚Äî **ÂÖ®Ë®òÊÜ∂Ê∂àÂéªÔºàÁÆ°ÁêÜËÄÖÂ∞ÇÁî®„ÉªÂÄã‰∫∫Ë°®Á§∫Ôºâ**",
        "„Éª/timer <hours> <minutes> [message] ‚Äî ÊåáÂÆö„ÅÆÊôÇÈñìÂæå„Å´ÈÄöÁü•ÔºàÂÖ®‰ΩìÔºâ",
        "„Éª/alarm <hour> <minute> [message] ‚Äî ÊåáÂÆöÊôÇÂàª„Å´1ÂõûÈÄöÁü•ÔºàÂÖ®‰ΩìÔºâ",
        "„Éª/omikuji ‚Äî „Åä„Åø„Åè„ÅòÔºàÂÖ®‰ΩìÔºâ",
        "„Éª/weather <place> ‚Äî Â§©Ê∞óÔºàÂÖ®‰ΩìÔºâ",
        "„Éª/dice <count> <sides> [plus] ‚Äî „ÉÄ„Ç§„ÇπÔºàÂÖ®‰ΩìÔºâ",
        "„Éª/rps <hand> ‚Äî „Åò„ÇÉ„Çì„Åë„ÇìÔºàÂÖ®‰ΩìÔºâ",
        "„Éª/which <options> [n] [unique] ‚Äî ÂÄôË£ú„Åã„ÇâÈÅ∏„Å∂ÔºàÂÖ®‰ΩìÔºâ",
        "-# ‚ìò„Åó„Åã„Åè„ÅÜ„Å§„ÅÆGemini Api„ÅØÊúâÊñô„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Åß„Åô„ÄÇ„Åø„Çì„Å™„Å´„Åó„Åã„Åè„ÅÜ„Å§„Å®ÈÅä„Çì„Åß„Åª„Åó„ÅÑ„ÅÆ„Åß„ÄÅÈ†ëÂºµ„Å£„Å¶Ë≥áÈáëÁπ∞„Çä„Çí„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        "-#  Âº∑Âà∂„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅ„ÇÇ„Åó„Äé„Åó„Åã„Åè„ÅÜ„Å§„Äè„ÅåÂ•Ω„Åç„Å†„Çà„Å£„Å¶„ÅÑ„ÅÜ‰∫∫„ÅØ‰∏∏„ÅÆÈ¨±„Å´Ë≥áÈáë„Çí„Å∂„Å°Êäï„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇË©≥„Åó„Åè„ÅØÊú¨‰∫∫„Åæ„Åß„ÄÇ",
    ]
    await interaction.response.send_message("\n".join(lines))


@client.tree.command(name="timer", description="‚óãÊôÇÈñì‚óãÂàÜÂæå„Å´ÈÄöÁü•„Åô„Çã„Çà")
@app_commands.describe(hours="0‰ª•‰∏ä„ÅÆÊôÇÈñì", minutes="0-59„ÅÆÂàÜ", message="‰ªªÊÑè: „É°„ÉÉ„Çª„Éº„Ç∏")
async def timer_cmd(interaction: discord.Interaction,
                    hours: app_commands.Range[int, 0, None],
                    minutes: app_commands.Range[int, 0, 59],
                    message: Optional[str] = None):
    if hours == 0 and minutes == 0:
        await interaction.response.send_message("0ÊôÇÈñì0ÂàÜ„ÅØË®≠ÂÆö„Åß„Åç„Å™„ÅÑ„Çà„ÄÇ",
                                                ephemeral=True)
        return
    delta = datetime.timedelta(hours=int(hours), minutes=int(minutes))
    target_utc = datetime.datetime.now(datetime.timezone.utc) + delta
    client.active_timers.append({
        "time": target_utc,
        "channel_id": interaction.channel.id,
        "user_id": interaction.user.id,
        "message": message or "ÊôÇÈñì„Å†„ÇàÔºÅ",
    })
    await interaction.response.send_message(
        f"„Çø„Ç§„Éû„ÉºOK„ÄÇ{hours}ÊôÇÈñì{minutes}ÂàÜÂæå„Å´Áü•„Çâ„Åõ„Çã„Å≠„ÄÇ")


@client.tree.command(name="alarm", description="‰ªäÊó•„ÅÆ‰ΩïÊôÇ‰ΩïÂàÜ„Å´‰∏ÄÂ∫¶„Å†„ÅëÈÄöÁü•„Åô„Çã„ÇàÔºàÈÅé„Åé„Å¶„Åü„ÇâÁøåÊó•„Å´Ôºâ")
@app_commands.describe(hour="0-23„ÅÆÊôÇ", minute="0-59„ÅÆÂàÜ", message="‰ªªÊÑè: „É°„ÉÉ„Çª„Éº„Ç∏")
async def alarm_cmd(interaction: discord.Interaction,
                    hour: app_commands.Range[int, 0, 23],
                    minute: app_commands.Range[int, 0, 59],
                    message: Optional[str] = None):
    now_local = datetime.datetime.now(TZ)
    try:
        target_local = now_local.replace(hour=int(hour),
                                         minute=int(minute),
                                         second=0,
                                         microsecond=0)
    except ValueError:
        await interaction.response.send_message("„Åù„ÅÆÊôÇÂàª„ÅØ„Åä„Åã„Åó„ÅÑ„Åã„ÇÇ„ÄÇ", ephemeral=True)
        return
    if target_local <= now_local:
        target_local += datetime.timedelta(days=1)
    target_utc = target_local.astimezone(datetime.timezone.utc)
    client.active_timers.append({
        "time": target_utc,
        "channel_id": interaction.channel.id,
        "user_id": interaction.user.id,
        "message": message or "Ëµ∑„Åç„Å¶ÔºÅ",
    })
    disp_day = target_local.strftime("%m/%d")
    await interaction.response.send_message(
        f"„Ç¢„É©„Éº„É†OK„ÄÇ{disp_day} {hour:02d}:{minute:02d} „Å´Áü•„Çâ„Åõ„Çã„Å≠„ÄÇ")


@client.tree.command(name="omikuji", description="„Åä„Åø„Åè„Åò„ÇíÂºï„Åè„ÇàÔºàÂ§ßÂêâ„ÄúÂ§ßÂá∂Ôºâ")
async def omikuji_cmd(interaction: discord.Interaction):
    results = [
        {
            "name": "Â§ßÂêâ",
            "message": "„Åï„Åô„Åå„Å†„Å≠ÔºÅ‰ªäÊó•„ÅØÁÑ°ÊïµÔºÅ‰Ωï„Çí„ÇÑ„Å£„Å¶„ÇÇ„ÅÜ„Åæ„Åè„ÅÑ„ÅèÊúÄÈ´ò„ÅÆ‰∏ÄÊó•ÔºÅ",
            "advice": "Êñ∞„Åó„ÅÑ„Åì„Å®„Å´ÊåëÊà¶„Åó„Å¶„Åø„Å¶ÔºÅ",
            "lucky_item": "ÂÖâ„Çã„ÇÇ„ÅÆ",
            "color": discord.Color.gold(),
            "weight": 5
        },
        {
            "name": "‰∏≠Âêâ",
            "message": "„ÅÑ„ÅÑ„Åã„Çì„ÅòÔºÅ„Åä„ÅÑ„Åó„ÅÑ„ÇÇ„ÅÆ„Åß„ÇÇ„Åü„Åπ„Çà„ÅÜÔºÅ",
            "advice": "Âë®„Çä„ÅÆ‰∫∫„Å´Ë¶™Âàá„Å´„Åô„Çã„Å®Âêâ„ÄÇ",
            "lucky_item": "„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆÈü≥Ê•Ω",
            "color": discord.Color.red(),
            "weight": 15
        },
        {
            "name": "Â∞èÂêâ",
            "message": "„Éó„ÉÅ„ÅÑ„ÅÑ„Åì„Å®„ÄÅ„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„Å≠„ÄÇ",
            "advice": "Ë∫´„ÅÆÂõû„Çä„ÅÆÊï¥ÁêÜÊï¥È†ì„ÇíÂøÉ„Åå„Åë„Å¶„ÄÇ",
            "lucky_item": "Ê§çÁâ©",
            "color": discord.Color.orange(),
            "weight": 20
        },
        {
            "name": "Âêâ",
            "message": "‰Ωï„ÇÇ„Å™„ÅÑÊó•„ÇÇ„ÅÑ„ÅÑ„Å≠„ÄÇÂπ≥Âíå„Åå‰∏ÄÁï™ÔºÅ",
            "advice": "„ÅÆ„Çì„Å≥„ÇäÈÅé„Åî„Åô„ÅÆ„ÅåËâØ„Åï„Åù„ÅÜ„ÄÇ",
            "lucky_item": "Ë™≠„Åø„Åã„Åë„ÅÆÊú¨",
            "color": discord.Color.green(),
            "weight": 25
        },
        {
            "name": "Êú´Âêâ",
            "message": "„ÅÇ„Çä„ÇÉÔºü„Åì„Çå„ÅØÁµê„Çì„ÅßÂ∏∞„Çç„ÅÜ„Å≠„ÄÇ",
            "advice": "Âøò„ÇåÁâ©„Å´Ê≥®ÊÑèÔºÅÁ¢∫Ë™ç„ÇíÊÄ†„Çâ„Å™„ÅÑ„Åß„ÄÇ",
            "lucky_item": "„Éè„É≥„Ç´„ÉÅ",
            "color": discord.Color.blue(),
            "weight": 20
        },
        {
            "name": "Âá∂",
            "message": "„ÅÜ„Çè„Çè„ÄÅ‰ªäÊó•„ÅØ„ÉÑ„Ç§„Å¶„Å™„ÅÑ„Åã„ÇÇ‚Ä¶",
            "advice": "ÊÖéÈáç„Å´Ë°åÂãï„Åó„Çà„ÅÜ„ÄÇÁÑ¶„Çä„ÅØÁ¶ÅÁâ©„ÄÇ",
            "lucky_item": "Ê∏©„Åã„ÅÑ„ÅäËå∂",
            "color": discord.Color.dark_grey(),
            "weight": 10
        },
        {
            "name": "Â§ßÂá∂",
            "message": "‰ªä„Åô„Åê„ÅäÊâï„ÅÑ„Å´Ë°å„Åì„ÅÜ‚Ä¶‚Ä¶üò≠",
            "advice": "‰ªäÊó•„ÅØÁÑ°ÁêÜ„Åõ„Åö„ÄÅÊó©„ÇÅ„Å´‰ºë„ÇÄ„ÅÆ„Åå‰∏ÄÁï™„ÄÇ",
            "lucky_item": "„ÅäÂÆà„Çä",
            # Color.black() „ÅØÁÑ°„ÅÑ„ÅÆ„Åß from_rgb(0,0,0) „Åã dark_grey() „Å´ÁΩÆÊèõ
            "color": discord.Color.dark_grey(),
            # „ÇÇ„ÅóÂÆåÂÖ®„Å™Èªí„ÅåËâØ„Åë„Çå„Å∞‰∏ãË®ò„ÅÆ„Å©„Å°„Çâ„Åã„Å´Â§âÊõ¥Ôºö
            # "color": discord.Color.from_rgb(0, 0, 0),
            # "color": discord.Color(0x000000),
            "weight": 5
        },
    ]

    population = [r for r in results]
    weights = [r["weight"] for r in results]
    pick = random.choices(population, weights=weights, k=1)[0]

    embed = discord.Embed(title=f"‰ªäÊó•„ÅÆÈÅãÂã¢„ÅØ‚Ä¶‚Ä¶ **{pick['name']}**ÔºÅ",
                          description=pick['message'],
                          color=pick['color'])
    embed.add_field(name="„Ç¢„Éâ„Éê„Ç§„Çπ", value=pick['advice'], inline=False)
    embed.add_field(name="„É©„ÉÉ„Ç≠„Éº„Ç¢„Ç§„ÉÜ„É†", value=pick['lucky_item'], inline=False)
    embed.set_footer(text=f"{interaction.user.display_name}„Åï„Çì„ÅÆ‰ªäÊó•„ÅÆÈÅãÂã¢")

    await interaction.response.send_message(embed=embed)


# ===== /weather =====


@client.tree.command(name="weather",
                     description="Âú∞Âêç„ÇíÂÖ•„Çå„Çã„Å®„ÄÅ‰ªäÊó•„Å®ÊòéÊó•„ÅÆÂ§©Ê∞ó„ÇíÊïô„Åà„Çã„ÇàÔºàOpen‚ÄëMeteoÔºâ")
@app_commands.describe(place="‰æã: ÂêçÂè§Â±ã, Tokyo, Osaka, Sapporo „Å™„Å©")
async def weather_cmd(interaction: discord.Interaction, place: str):
    await interaction.response.defer()  # 3Áßí„É´„Éº„É´ÂõûÈÅø
    if client.session is None:
        await interaction.followup.send("ÂÜÖÈÉ®„Ç®„É©„Éº: HTTP„Çª„ÉÉ„Ç∑„Éß„É≥Êú™ÂàùÊúüÂåñ", ephemeral=True)
        return

    geo = await geocode_place(client.session, place, language="ja")
    if not geo:
        await interaction.followup.send(f"„Äé{place}„Äè„ÅåË¶ã„Å§„Åã„Çâ„Å™„Åã„Å£„Åü„Çà‚Ä¶‚Ä¶Âà•„ÅÆË®Ä„ÅÑÊñπ„ÅßË©¶„Åó„Å¶„Åø„Å¶ÔºÅ",
                                        ephemeral=True)
        return

    lat, lon, label = geo
    data = await fetch_forecast(client.session, lat, lon, tzname=DEFAULT_TZ)
    if not data:
        await interaction.followup.send("‰∫àÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Å°„ÇÉ„Å£„Åü„ÄÇ„Å°„Çá„Å£„Å®ÊôÇÈñì„Çí„Åä„ÅÑ„Å¶„Åø„Å¶„ÄÇ",
                                        ephemeral=True)
        return

    daily = data.get("daily", {})
    times = daily.get("time", [])
    wcodes = daily.get("weathercode", [])
    tmax = daily.get("temperature_2m_max", [])
    tmin = daily.get("temperature_2m_min", [])
    prcp = daily.get("precipitation_sum", [])
    wind = daily.get("wind_speed_10m_max", [])

    def row(idx: int) -> str:
        if idx >= len(times):
            return "‚Äî"
        d = times[idx]
        wc = wmo_to_text(wcodes[idx])[0] if idx < len(wcodes) else "‚Äî"
        em = wmo_to_text(wcodes[idx])[1] if idx < len(wcodes) else ""
        hi = f"{tmax[idx]:.0f}¬∞C" if idx < len(tmax) else "‚Äî"
        lo = f"{tmin[idx]:.0f}¬∞C" if idx < len(tmin) else "‚Äî"
        pp = f"{prcp[idx]:.1f}mm" if idx < len(prcp) else "‚Äî"
        wd = f"{wind[idx]:.0f}m/s" if idx < len(wind) else "‚Äî"
        return f"{d}  {em} {wc}  ÊúÄÈ´ò {hi} / ÊúÄ‰Ωé {lo}  ÈôçÊ∞¥ {pp}  È¢® {wd}"

    embed = discord.Embed(title=f"{label} „ÅÆÂ§©Ê∞óÔºà{DEFAULT_TZ}Ôºâ",
                          color=discord.Color.blue())
    embed.add_field(name="‰ªäÊó•", value=row(0), inline=False)
    if len(times) > 1:
        embed.add_field(name="ÊòéÊó•", value=row(1), inline=False)
    embed.set_footer(text="Powered by Open‚ÄëMeteo")

    await interaction.followup.send(embed=embed)


# ===== /dice =====


@client.tree.command(name="dice",
                     description="„ÉÄ„Ç§„Çπ„ÇíÊåØ„Çã„ÇàÔºö/dice <ÂÄãÊï∞> <Èù¢Êï∞> [Âä†ÁÆó] ‰æã) /dice 2 6 3")
@app_commands.describe(count="ÊåØ„ÇãÂÄãÊï∞Ôºà1-100Ôºâ",
                       sides="‰ΩïÈù¢„ÉÄ„Ç§„Çπ„ÅãÔºà2-1000Ôºâ",
                       plus="ÂêàË®à„Å´Ë∂≥„Åô‰øÆÊ≠£ÂÄ§Ôºà‰ªªÊÑè„ÄÅ-999„Äú999Ôºâ")
async def dice_cmd(interaction: discord.Interaction,
                   count: app_commands.Range[int, 1, 100],
                   sides: app_commands.Range[int, 2, 1000],
                   plus: Optional[app_commands.Range[int, -999, 999]] = 0):
    rolls = [random.randint(1, sides) for _ in range(count)]
    total = sum(rolls) + int(plus or 0)

    # Èï∑„Åô„Åé„ÇãÊôÇ„ÅØÈÄî‰∏≠ÁúÅÁï•
    if len(rolls) > 50:
        head = ", ".join(map(str, rolls[:25]))
        tail = ", ".join(map(str, rolls[-25:]))
        rolls_text = f"{head}, ‚Ä¶, {tail}"
    else:
        rolls_text = ", ".join(map(str, rolls))

    mod_text = f" + {plus}" if plus and plus > 0 else (
        f" - {abs(plus)}" if plus and plus < 0 else "")
    embed = discord.Embed(title="üé≤ „ÉÄ„Ç§„ÇπÁµêÊûú", color=discord.Color.teal())
    embed.add_field(name="Âºè", value=f"{count}d{sides}{mod_text}", inline=True)
    embed.add_field(name="ÂêàË®à", value=str(total), inline=True)
    embed.add_field(name="Âá∫ÁõÆ", value=rolls_text or "(„Å™„Åó)", inline=False)
    await interaction.response.send_message(embed=embed)


# ===== /rps =====


@client.tree.command(name="rps", description="„Åò„ÇÉ„Çì„Åë„ÇìÔºö„Ç∞„Éº/„ÉÅ„Éß„Ç≠/„Éë„Éº„ÅßÂãùË≤†ÔºÅ")
@app_commands.describe(hand="„Ç∞„Éº / „ÉÅ„Éß„Ç≠ / „Éë„Éº")
async def rps_cmd(interaction: discord.Interaction, hand: Literal["„Ç∞„Éº", "„ÉÅ„Éß„Ç≠",
                                                                  "„Éë„Éº"]):
    bot_map = {"„Ç∞„Éº": "‚úä", "„ÉÅ„Éß„Ç≠": "‚úåÔ∏è", "„Éë„Éº": "üñêÔ∏è"}
    you = hand
    bot = random.choice(list(bot_map.keys()))

    # ÂãùÊïóÂà§ÂÆö
    rules = {"„Ç∞„Éº": "„ÉÅ„Éß„Ç≠", "„ÉÅ„Éß„Ç≠": "„Éë„Éº", "„Éë„Éº": "„Ç∞„Éº"}
    if you == bot:
        result = "Âºï„ÅçÂàÜ„ÅëÔºÅ„ÇÇ„ÅÜ‰∏ÄÊà¶„ÅÑ„ÅèÔºü"
    elif rules[you] == bot:
        result = "Âãù„Å°ÔºÅ„ÇÑ„Çã„Åò„ÇÉ„ÇìÔºÅ"
    else:
        result = "Ë≤†„ÅëÔºÅ„Éâ„É≥„Éû„Ç§„ÄÅÊ¨°„ÅØÂãù„Å®„ÅÜ„ÄÇ"

    embed = discord.Embed(title="‚úä‚úåÔ∏èüñêÔ∏è „Åò„ÇÉ„Çì„Åë„Çì", color=discord.Color.blurple())
    embed.add_field(name="„ÅÇ„Å™„Åü", value=f"{bot_map[you]} {you}")
    embed.add_field(name="„Åó„Åã„Åè„ÅÜ„Å§", value=f"{bot_map[bot]} {bot}")
    embed.add_field(name="ÁµêÊûú", value=result, inline=False)
    await interaction.response.send_message(embed=embed)


# ===== /which =====


@client.tree.command(name="which", description="ÂÄôË£ú„Åã„Çâ„É©„É≥„ÉÄ„É†„Å´ÈÅ∏„Å∂„Çà")
@app_commands.describe(options="ÂÄôË£ú„ÇíÂå∫Âàá„Å£„Å¶ÂÖ•ÂäõÔºà, „ÇÑ | „ÇÑ Á©∫ÁôΩ„ÅßOKÔºâ",
                       n="ÈÅ∏„Å∂Êï∞Ôºà1-10Ôºâ",
                       unique="Âêå„ÅòÂÄôË£ú„ÇíÈáçË§á„Åï„Åõ„Å™„ÅÑ")
async def which_cmd(interaction: discord.Interaction,
                    options: str,
                    n: app_commands.Range[int, 1, 10] = 1,
                    unique: bool = True):
    # Âå∫Âàá„ÇäÊñáÂ≠óÔºö„Ç´„É≥„Éû„ÄÅ„Éë„Ç§„Éó„ÄÅ„Çπ„Éö„Éº„Çπ„ÄÅÊó•Êú¨Ë™ûË™≠ÁÇπ„Å™„Å©
    items = [s.strip() for s in re.split(r"[|,„ÄÅ\s]+", options) if s.strip()]

    # ÈáçË§áÈô§ÂéªÔºàÈ†ÜÂ∫èÁ∂≠ÊåÅÔºâ
    seen = set()
    dedup = []
    for x in items:
        if x not in seen:
            seen.add(x)
            dedup.append(x)

    if len(dedup) < 2:
        await interaction.response.send_message(
            "ÂÄôË£ú„ÅØ2„Å§‰ª•‰∏äÂÖ•„Çå„Å¶„Å≠„ÄÇ‰æãÔºö/which „É©„Éº„É°„É≥, „Ç´„É¨„Éº, ÂØøÂè∏", ephemeral=True)
        return

    if unique and n > len(dedup):
        await interaction.response.send_message("unique=Áúü „ÅÆ„Å®„Åç„ÅØ„ÄÅÈÅ∏„Å∂Êï∞„ÅØÂÄôË£úÊï∞‰ª•‰∏ã„Å´„Åó„Å¶„Å≠„ÄÇ",
                                                ephemeral=True)
        return

    picks = (random.sample(dedup, k=n)
             if unique else [random.choice(dedup) for _ in range(n)])

    embed = discord.Embed(title="üéØ „É©„É≥„ÉÄ„É†„ÉÅ„Éß„Ç§„Çπ", color=discord.Color.green())
    embed.add_field(name="ÂÄôË£ú", value=", ".join(dedup)[:1000], inline=False)
    embed.add_field(name="ÈÅ∏„Å∞„Çå„Åü„ÅÆ„ÅØ‚Ä¶", value=" / ".join(picks), inline=False)
    if not unique and n > 1:
        embed.set_footer(text="‚Äª ÈáçË§á„ÅÇ„Çä„ÅßÈÅ∏„Çì„Åß„ÅÑ„Åæ„Åô")
    await interaction.response.send_message(embed=embed)


# ===== „Ç®„É©„Éº„Éè„É≥„Éâ„É© =====


@client.tree.error
async def on_app_command_error(interaction: discord.Interaction,
                               error: app_commands.AppCommandError):
    try:
        if isinstance(error, app_commands.CommandInvokeError):
            msg = f"ÂÆüË°å‰∏≠„Å´„Ç®„É©„Éº: {error.original}"
        elif isinstance(error, app_commands.TransformerError):
            msg = "ÂºïÊï∞„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„Å™„ÅÑ„Åø„Åü„ÅÑ‚Ä¶"
        elif isinstance(error, app_commands.MissingPermissions):
            msg = "Ê®©Èôê„ÅåË∂≥„Çä„Å™„ÅÑ„Çà‚Ä¶‚Ä¶"
        else:
            msg = f"„Ç®„É©„Éº: {error}"
        if interaction.response.is_done():
            await interaction.followup.send(msg, ephemeral=True)
        else:
            await interaction.response.send_message(msg, ephemeral=True)
    except Exception as e:
        print(f"[SlashErrorHandler] failed to respond: {e}")


def main():
    if not TOKEN:
        print("„Ç®„É©„Éº: DISCORD_TOKEN„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Éõ„Çπ„ÉàÁí∞Â¢É„ÅÆÁí∞Â¢ÉÂ§âÊï∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        return
    try:
        client.run(TOKEN)
    except discord.LoginFailure:
        print("„Ç®„É©„Éº: „Éà„Éº„ÇØ„É≥„ÅåÁÑ°Âäπ„Åã„ÇÇ„ÄÇÂÜçÁô∫Ë°å/„Ç≥„Éî„Éº„ÅóÁõ¥„Åó„Å¶„Å≠„ÄÇ")
    except Exception as e:
        print(f"[Run] Unexpected error: {e}")


if __name__ == "__main__":
    main()
